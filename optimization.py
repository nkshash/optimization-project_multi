# -*- coding: utf-8 -*-
"""Optimization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Bu2rh5yWkCpz5JlkJR8TqueYz9y97rzy
"""

# Commented out IPython magic to ensure Python compatibility.
!pip install ipython-autotime
# %load_ext autotime

#libraries
import math as m

#energy for wind turbine, values we used are written there
v=float(input("Enter the wind speed in meter/second ")) #15.2778
r=float(input("Enter the radius of blade in metre")) #63.75
a=m.pi*(r**2)
cp=0.59 #Betz Limit
cg=float(input("enter the generator efficiency")) #0.9
nt=int(input("enter the no of winds turbine in one plant")) #15
rho=1.1906 
pw=0.5*rho*a*(v**3)*cp*cg*nt*2.7777*(10**(-7))

#environmental ascept
enw=7.5*(10**5) + 12*(10**7)*pw*365*24
#economical effect
ecw=1600*pw

print(pw)
print(enw)
print(ecw)

#for solar panel r is solar panel yield (%), H is annual average solar radiation on tilted panels and PR = Performan...


nefso=float(input("input efficiency of solar plant because of loss")) #0.9
AreaSo=float(input("input area of solar panel in m^2")) #1.7
RSo=float(input("solar panel yield %")) #15.6
PR=float(input("performance ratio")) #0.75
H=float(input("annual average solar radiation")) #1361
Numberso=int(input("no of solar plates in one plant")) #6000
pso=nefso*AreaSo*RSo*PR*H*Numberso*2.7777*(10**(-7))

#environmental ascept
enso=19*(10**5) + 40*(10**7)*pso*365*24
#economical effect
ecso=830*pso

print(pso)
print(enso)
print(ecso)

#for coal
mcoal=float(input("mass of coal used per second in tonnes")) #27
nefc=float(input("input efficiency of coal power plant")) #0.33
caf=float(input("input calorific value of coal in Mj/kg")) #28.5
pco=nefc*mcoal*caf*1000000*2.7777*(10**(-7))

#environmental ascept
enco=15*(10**5) + 1011.511*(10**7)*pco*365*24
#economical effect
ecco=3500*pco

print(pco)
print(enco)
print(ecco)

#for petroleum
lpet=float(input("litre of crude oil per second"))#0.03028
nefp=float(input("input efficiency of oil plant"))#0.33
cafp=float(input("input calorific value of crude oil Mj/Kg"))#45
densitycrude=850
ppe=nefp*lpet*cafp*densitycrude*1000000*2.7777*(10**(-7))

#environmental ascept
enpe=15*(10**5) + 966.1517*(10**7)*ppe*365*24
#economical effect
ecpe=600*ppe

print(ppe)
print(enpe)
print(ecpe)

#for natural gas
lng=float(input("volume of natural gas in litre"))#8.4
nefng=float(input("input efficiency of natural gas plant"))#0.8
cafng=float(input("input calorific value of natural gas"))#50
densitygas=0.97
png=nefng*lng*densitygas*cafng*1000000*2.7777*(10**(-7))

#environmental ascept
enng=1*(10**5) + 412.7691*(10**7)*png*365*24
#economical effect
ecng=710*png

print(png)
print(enng)
print(ecng)

#for hydropower plant
height=float(input("height of hydroplant"))#20
area=float(input("enter area of plant"))#112.409530
neffhydro=float(input("efficiency of hydroplant"))#0.54
phydro=neffhydro*1000*area*9.81*0.9*0.9*height*height*2.7777*(10**(-7))

#environmental ascept
enhydro=33*(10**5) + 24*(10**7)*phydro*365*24
#economical effect
echydro=2752*phydro

print(phydro)
print(enhydro)
print(echydro)

#nuclear
mnu=float(input("mass of nuclear fuel"))#0.017625
nefnu=float(input("input efficiency of nuclear"))#0.45
cafnu=float(input("input calorific value of nuclear"))#24000
pnu=nefnu*mnu*cafnu*2.7777*(10**(-7))*1000000

#environmental ascept
ennu=0.3*(10**5) + 12*(10**7)*pnu*365*24
#economical effect
ecnu=6000*pnu

print(pnu)
print(ennu)
print(ecnu)

#constraints
preq=float(input("Input power requirement in BU per month"))

Power1=-1*preq*1000000/(30*24)
pextra=float(input("storage capacity of power in BU per month"))

Power2=-1*pextra*1000000/(30*24)

print(Power1)

print(Power2)

!pip install pymoo

max=10**3

from pymoo.core.problem import ElementwiseProblem
from pymoo.core.variable import Real, Integer
class MultiObjectiveMixedVariableProblem(ElementwiseProblem):

    def __init__(self, **kwargs):
        vars = {
            "nnu": Integer(bounds=(0, max )),
            "nhydro": Integer(bounds=(0, max )),
            "nng": Integer(bounds=(0, max )),
            "npe": Integer(bounds=(0, max )),
            "nco": Integer(bounds=(0, max )),
            "nw": Integer(bounds=(0, max )),
            "nso": Integer(bounds=(0, max )),

           
        }
        super().__init__(vars=vars, n_obj=3, n_ieq_constr=2, **kwargs)
    def _evaluate(self, X, out, *args, **kwargs):
        nnu, nhydro, nng, npe, nco, nw, nso = X["nnu"], X["nhydro"], X["nng"], X["npe"], X["nco"], X["nw"], X["nso"] 

        f1 = -1*(pco*nco +pw*nw +pso*nso + pnu*nnu +phydro*nhydro +png*nng + ppe*npe ) 
        f2 =  (ecco*nco +ecw*nw +ecso*nso + ecnu*nnu +echydro*nhydro +ecng*nng + ecpe*npe ) 
        f3 =  (enco*nco +enw*nw +enso*nso + ennu*nnu +enhydro*nhydro +enng*nng + enpe*npe ) 

        g1  = f1-Power1
        g2  = Power1+Power2-f1

        out["F"] = [f1, f2, f3 ]
        out["G"]=  [g1 ,g2]

from pymoo.visualization.scatter import Scatter
from pymoo.algorithms.moo.nsga2 import NSGA2, RankAndCrowdingSurvival
from pymoo.core.mixed import MixedVariableMating, MixedVariableGA, MixedVariableSampling, MixedVariableDuplicateElimination
from pymoo.optimize import minimize
problem=MultiObjectiveMixedVariableProblem()
algorithm = NSGA2(pop_size=100,
                  sampling=MixedVariableSampling(),
                  mating=MixedVariableMating(eliminate_duplicates=MixedVariableDuplicateElimination()),
                  eliminate_duplicates=MixedVariableDuplicateElimination(),
                  )
res = minimize(problem,
               algorithm,
               ('n_gen', 50000),
               seed=1,
               verbose=False)

!pip install plotly

print(res.X)

print(res.F)

df=res.F

import numpy as np
weights = np.array([0.1, 0.6, 0.3])
from pymoo.decomposition.asf import ASF
import pandas as pd

decomp = ASF()
i = decomp.do(df, 1/weights).argmin()
print("Best regarding ASF: Point \ni = %s\nres = %s" % (i, df[i]))

print(df)

number=res.X
print(number)

number[i]

import plotly.express as px
import plotly.graph_objects as go

import pandas as pd
df = res.F
dict = {'power':df[:,0],
        'economic':df[:,1],
        'environmental':df[:,2]
       }
dataf = pd.DataFrame(dict)
  
display(dataf)
fig = px.scatter_3d(dataf,'power', y='economic', z='environmental')

fig.show()

print(dataf)

from pymoo.visualization.scatter import Scatter
from pymoo.algorithms.moo.nsga2 import RankAndCrowdingSurvival
from pymoo.core.mixed import MixedVariableGA
from pymoo.optimize import minimize

problem = MultiObjectiveMixedVariableProblem()

algorithm = MixedVariableGA(pop_size=100, survival=RankAndCrowdingSurvival())

res = minimize(problem,
               algorithm,
               ('n_gen', 500),
               seed=1,
               verbose=False)

import pandas as pd
df = res.F
dict = {'power':df[:,0],
        'economic':df[:,1],
        'environmental':df[:,2]
       }
dataf = pd.DataFrame(dict)
  
display(dataf)
fig = px.scatter_3d(dataf, x='power', y='economic', z='environmental')
fig.show()

import numpy as np
weights = np.array([0.1, 0.6, 0.3])
from pymoo.decomposition.asf import ASF
import plotly.graph_objects as go
import numpy as np
decomp = ASF()
i = decomp.do(df, 1/weights).argmin()
print("Best regarding ASF: Point \ni = %s\nF = %s" % (i, df[i]))

#fig.show()

print(res.X[i])